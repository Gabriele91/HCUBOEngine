parameters
{
    mask float(-1.0)
    diffuse_map texture("white")
    normal_map texture("normal_up")
    specular_map texture("black")
    height_map texture("black")
	uv_height_offset vec2(0.0,0.0)
	uv_height_step vec2(1.0,1.0)
	color vec4(1.0,1.0,1.0,1.0)
}

sub_effect
{
    requirement
    {
        driver  OpenGL(4,1)
        shader  GLSL(410)
    }
    
    technique "forward"
    {
        pass 
        {
            zbuffer less
            blend off
            cullface back
            lights only_ambient
            shader source 
            {
                #define FORWARD_RENDERING
                #pragma import <base_texture_normal_specular>
            }
        }
        pass 
        {
            zbuffer equal
            blend one one
            cullface back
            lights spot_point_direction
            shader source 
            {
                #define FORWARD_RENDERING
                #pragma import <base_texture_normal_specular>
            }
        }
    }

    technique "deferred"
    {
        pass
        {
            zbuffer less
            blend off
            cullface back
            lights off
            shader source
            {
                #define DEFERRED_RENDERING
				#define USE_VERTEX_SHADER
				#pragma import <base_texture_normal_specular>
				/////////////////////////////////////////////////////////
				#pragma vertex
				
				uniform vec2 uv_height_offset;
				uniform vec2 uv_height_step;
				uniform sampler2D height_map;
				
				//define function
				void vertex_shader(out vertex_output output)
				{
					//compute uv
					output.m_uvmap = uv_height_offset + vertex.xy * uv_height_step;
					//compute height
					float height = texture( height_map, output.m_uvmap ).r - 0.5;
					//compute vertex
					vec4  position = vec4(output.m_uvmap.x - 0.5, height, output.m_uvmap.y - 0.5, 1.0);
					//compute vertex in model space
					output.m_world_position = transform.m_model * position;
					//compute vertex in projection space
					output.m_position = camera.m_projection * camera.m_view * output.m_world_position;
				}            
			}
        }
    }
}
